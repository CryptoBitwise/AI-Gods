{"ast":null,"code":"class MemoryService {\n  constructor() {\n    this.db = void 0;\n    // Will be SQLite database\n    this.isInitialized = false;\n    this.initializeDatabase();\n  }\n  async initializeDatabase() {\n    try {\n      // For now, we'll use localStorage as a fallback\n      // Later we'll integrate with actual SQLite\n      this.isInitialized = true;\n      console.log('ðŸ§  Memory Service initialized');\n    } catch (error) {\n      console.error('Failed to initialize memory service:', error);\n    }\n  }\n\n  // Create or update god memory\n  async updateGodMemory(godId, memory) {\n    if (!this.isInitialized) return;\n    try {\n      const existing = await this.getGodMemory(godId);\n      const updated = {\n        ...existing,\n        ...memory\n      };\n\n      // Store in localStorage for now\n      localStorage.setItem(`god_memory_${godId}`, JSON.stringify(updated));\n      console.log(`ðŸ§  Updated memory for ${godId}`);\n    } catch (error) {\n      console.error('Failed to update god memory:', error);\n    }\n  }\n\n  // Get god's memory\n  async getGodMemory(godId) {\n    if (!this.isInitialized) return null;\n    try {\n      const stored = localStorage.getItem(`god_memory_${godId}`);\n      if (stored) {\n        const memory = JSON.parse(stored);\n        // Convert timestamp strings back to Date objects\n        memory.memories = memory.memories.map(m => ({\n          ...m,\n          timestamp: new Date(m.timestamp)\n        }));\n        return memory;\n      }\n      return null;\n    } catch (error) {\n      console.error('Failed to get god memory:', error);\n      return null;\n    }\n  }\n\n  // Add a new memory entry\n  async addMemory(godId, memory) {\n    if (!this.isInitialized) return;\n    try {\n      const godMemory = await this.getGodMemory(godId);\n      if (!godMemory) return;\n      const newMemory = {\n        ...memory,\n        id: `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        timestamp: new Date()\n      };\n      godMemory.memories.push(newMemory);\n\n      // Keep only last 100 memories to prevent bloat\n      if (godMemory.memories.length > 100) {\n        godMemory.memories = godMemory.memories.sort((a, b) => b.importance - a.importance).slice(0, 100);\n      }\n      await this.updateGodMemory(godId, godMemory);\n      console.log(`ðŸ§  Added memory to ${godId}: ${memory.content.substring(0, 50)}...`);\n    } catch (error) {\n      console.error('Failed to add memory:', error);\n    }\n  }\n\n  // Get relevant memories for context\n  async getRelevantMemories(godId, query, limit = 5) {\n    if (!this.isInitialized) return [];\n    try {\n      const godMemory = await this.getGodMemory(godId);\n      if (!godMemory) return [];\n\n      // Simple relevance scoring based on content and tags\n      const scored = godMemory.memories.map(memory => {\n        let score = memory.importance;\n\n        // Boost score if query matches content or tags\n        if (memory.content.toLowerCase().includes(query.toLowerCase())) score += 5;\n        if (memory.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()))) score += 3;\n        return {\n          memory,\n          score\n        };\n      });\n\n      // Return top memories by score\n      return scored.sort((a, b) => b.score - a.score).slice(0, limit).map(item => item.memory);\n    } catch (error) {\n      console.error('Failed to get relevant memories:', error);\n      return [];\n    }\n  }\n\n  // Update god's personality based on interactions\n  async updatePersonality(godId, changes) {\n    if (!this.isInitialized) return;\n    try {\n      const godMemory = await this.getGodMemory(godId);\n      if (!godMemory) return;\n      godMemory.personality = {\n        ...godMemory.personality,\n        ...changes\n      };\n      await this.updateGodMemory(godId, godMemory);\n      console.log(`ðŸ§  Updated personality for ${godId}`);\n    } catch (error) {\n      console.error('Failed to update personality:', error);\n    }\n  }\n\n  // Record a ritual\n  async recordRitual(ritual) {\n    if (!this.isInitialized) return;\n    try {\n      const newRitual = {\n        ...ritual,\n        id: `ritual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        timestamp: new Date()\n      };\n\n      // Store ritual in localStorage\n      const rituals = JSON.parse(localStorage.getItem('rituals') || '[]');\n      rituals.push(newRitual);\n      localStorage.setItem('rituals', JSON.stringify(rituals));\n      console.log(`ðŸ§  Recorded ritual: ${ritual.ritualType}`);\n    } catch (error) {\n      console.error('Failed to record ritual:', error);\n    }\n  }\n\n  // Get user profile\n  async getUserProfile(userId) {\n    if (!this.isInitialized) return null;\n    try {\n      const stored = localStorage.getItem(`user_profile_${userId}`);\n      if (stored) {\n        const profile = JSON.parse(stored);\n        profile.lastActive = new Date(profile.lastActive);\n        return profile;\n      }\n      return null;\n    } catch (error) {\n      console.error('Failed to get user profile:', error);\n      return null;\n    }\n  }\n\n  // Update user profile\n  async updateUserProfile(userId, updates) {\n    if (!this.isInitialized) return;\n    try {\n      const existing = await this.getUserProfile(userId);\n      const updated = {\n        ...existing,\n        ...updates,\n        lastActive: new Date()\n      };\n      localStorage.setItem(`user_profile_${userId}`, JSON.stringify(updated));\n      console.log(`ðŸ§  Updated user profile for ${userId}`);\n    } catch (error) {\n      console.error('Failed to update user profile:', error);\n    }\n  }\n\n  // Get all gods' memories (for pantheon view)\n  async getAllGodMemories() {\n    if (!this.isInitialized) return [];\n    try {\n      const memories = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key !== null && key !== void 0 && key.startsWith('god_memory_')) {\n          const memory = await this.getGodMemory(key.replace('god_memory_', ''));\n          if (memory) memories.push(memory);\n        }\n      }\n      return memories;\n    } catch (error) {\n      console.error('Failed to get all god memories:', error);\n      return [];\n    }\n  }\n\n  // Clear all data (for testing)\n  async clearAllData() {\n    if (!this.isInitialized) return;\n    try {\n      // Clear all god memories\n      for (let i = localStorage.length - 1; i >= 0; i--) {\n        const key = localStorage.key(i);\n        if (key !== null && key !== void 0 && key.startsWith('god_memory_') || key !== null && key !== void 0 && key.startsWith('user_profile_') || key === 'rituals') {\n          localStorage.removeItem(key);\n        }\n      }\n      console.log('ðŸ§  Cleared all memory data');\n    } catch (error) {\n      console.error('Failed to clear data:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const memoryService = new MemoryService();\nexport default memoryService;","map":{"version":3,"names":["MemoryService","constructor","db","isInitialized","initializeDatabase","console","log","error","updateGodMemory","godId","memory","existing","getGodMemory","updated","localStorage","setItem","JSON","stringify","stored","getItem","parse","memories","map","m","timestamp","Date","addMemory","godMemory","newMemory","id","now","Math","random","toString","substr","push","length","sort","a","b","importance","slice","content","substring","getRelevantMemories","query","limit","scored","score","toLowerCase","includes","tags","some","tag","item","updatePersonality","changes","personality","recordRitual","ritual","newRitual","rituals","ritualType","getUserProfile","userId","profile","lastActive","updateUserProfile","updates","getAllGodMemories","i","key","startsWith","replace","clearAllData","removeItem","memoryService"],"sources":["D:/AI-Gods/src/services/memory.ts"],"sourcesContent":["export interface MemoryEntry {\r\n    id: string;\r\n    timestamp: Date;\r\n    type: 'conversation' | 'offering' | 'ritual' | 'lore' | 'interaction';\r\n    content: string;\r\n    metadata: Record<string, any>;\r\n    importance: number; // 1-10, how important this memory is\r\n    tags: string[];\r\n}\r\n\r\nexport interface GodMemory {\r\n    godId: string;\r\n    godName: string;\r\n    domain: string;\r\n    temperament: string;\r\n    memories: MemoryEntry[];\r\n    personality: {\r\n        currentMood: string;\r\n        relationshipWithUser: number; // -100 to 100\r\n        knowledgeLevel: number; // 1-100\r\n        corruptionLevel: number; // 0-100\r\n        specialAbilities: string[];\r\n    };\r\n    lore: {\r\n        creationDate: Date;\r\n        domains: string[];\r\n        sacredRules: string[];\r\n        taboos: string[];\r\n        allies: string[];\r\n        enemies: string[];\r\n        achievements: string[];\r\n    };\r\n    sessions: {\r\n        totalSessions: number;\r\n        lastSession: Date;\r\n        favoriteTopics: string[];\r\n        userPreferences: Record<string, any>;\r\n    };\r\n}\r\n\r\nexport interface RitualMemory {\r\n    id: string;\r\n    timestamp: Date;\r\n    ritualType: string;\r\n    participants: string[];\r\n    outcome: string;\r\n    effects: string[];\r\n    offerings: string[];\r\n    divineResponse: string;\r\n}\r\n\r\nexport interface UserProfile {\r\n    userId: string;\r\n    username: string;\r\n    divineStanding: number;\r\n    favoriteGods: string[];\r\n    completedRituals: RitualMemory[];\r\n    offerings: string[];\r\n    achievements: string[];\r\n    lastActive: Date;\r\n}\r\n\r\nclass MemoryService {\r\n    private db: any; // Will be SQLite database\r\n    private isInitialized = false;\r\n\r\n    constructor() {\r\n        this.initializeDatabase();\r\n    }\r\n\r\n    private async initializeDatabase() {\r\n        try {\r\n            // For now, we'll use localStorage as a fallback\r\n            // Later we'll integrate with actual SQLite\r\n            this.isInitialized = true;\r\n            console.log('ðŸ§  Memory Service initialized');\r\n        } catch (error) {\r\n            console.error('Failed to initialize memory service:', error);\r\n        }\r\n    }\r\n\r\n    // Create or update god memory\r\n    async updateGodMemory(godId: string, memory: Partial<GodMemory>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const existing = await this.getGodMemory(godId);\r\n            const updated = { ...existing, ...memory };\r\n\r\n            // Store in localStorage for now\r\n            localStorage.setItem(`god_memory_${godId}`, JSON.stringify(updated));\r\n\r\n            console.log(`ðŸ§  Updated memory for ${godId}`);\r\n        } catch (error) {\r\n            console.error('Failed to update god memory:', error);\r\n        }\r\n    }\r\n\r\n    // Get god's memory\r\n    async getGodMemory(godId: string): Promise<GodMemory | null> {\r\n        if (!this.isInitialized) return null;\r\n\r\n        try {\r\n            const stored = localStorage.getItem(`god_memory_${godId}`);\r\n            if (stored) {\r\n                const memory = JSON.parse(stored);\r\n                // Convert timestamp strings back to Date objects\r\n                memory.memories = memory.memories.map((m: any) => ({\r\n                    ...m,\r\n                    timestamp: new Date(m.timestamp)\r\n                }));\r\n                return memory;\r\n            }\r\n            return null;\r\n        } catch (error) {\r\n            console.error('Failed to get god memory:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Add a new memory entry\r\n    async addMemory(godId: string, memory: Omit<MemoryEntry, 'id' | 'timestamp'>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const godMemory = await this.getGodMemory(godId);\r\n            if (!godMemory) return;\r\n\r\n            const newMemory: MemoryEntry = {\r\n                ...memory,\r\n                id: `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n                timestamp: new Date()\r\n            };\r\n\r\n            godMemory.memories.push(newMemory);\r\n\r\n            // Keep only last 100 memories to prevent bloat\r\n            if (godMemory.memories.length > 100) {\r\n                godMemory.memories = godMemory.memories\r\n                    .sort((a, b) => b.importance - a.importance)\r\n                    .slice(0, 100);\r\n            }\r\n\r\n            await this.updateGodMemory(godId, godMemory);\r\n            console.log(`ðŸ§  Added memory to ${godId}: ${memory.content.substring(0, 50)}...`);\r\n        } catch (error) {\r\n            console.error('Failed to add memory:', error);\r\n        }\r\n    }\r\n\r\n    // Get relevant memories for context\r\n    async getRelevantMemories(godId: string, query: string, limit: number = 5): Promise<MemoryEntry[]> {\r\n        if (!this.isInitialized) return [];\r\n\r\n        try {\r\n            const godMemory = await this.getGodMemory(godId);\r\n            if (!godMemory) return [];\r\n\r\n            // Simple relevance scoring based on content and tags\r\n            const scored = godMemory.memories.map(memory => {\r\n                let score = memory.importance;\r\n\r\n                // Boost score if query matches content or tags\r\n                if (memory.content.toLowerCase().includes(query.toLowerCase())) score += 5;\r\n                if (memory.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()))) score += 3;\r\n\r\n                return { memory, score };\r\n            });\r\n\r\n            // Return top memories by score\r\n            return scored\r\n                .sort((a, b) => b.score - a.score)\r\n                .slice(0, limit)\r\n                .map(item => item.memory);\r\n        } catch (error) {\r\n            console.error('Failed to get relevant memories:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    // Update god's personality based on interactions\r\n    async updatePersonality(godId: string, changes: Partial<GodMemory['personality']>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const godMemory = await this.getGodMemory(godId);\r\n            if (!godMemory) return;\r\n\r\n            godMemory.personality = { ...godMemory.personality, ...changes };\r\n            await this.updateGodMemory(godId, godMemory);\r\n\r\n            console.log(`ðŸ§  Updated personality for ${godId}`);\r\n        } catch (error) {\r\n            console.error('Failed to update personality:', error);\r\n        }\r\n    }\r\n\r\n    // Record a ritual\r\n    async recordRitual(ritual: Omit<RitualMemory, 'id' | 'timestamp'>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const newRitual: RitualMemory = {\r\n                ...ritual,\r\n                id: `ritual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n                timestamp: new Date()\r\n            };\r\n\r\n            // Store ritual in localStorage\r\n            const rituals = JSON.parse(localStorage.getItem('rituals') || '[]');\r\n            rituals.push(newRitual);\r\n            localStorage.setItem('rituals', JSON.stringify(rituals));\r\n\r\n            console.log(`ðŸ§  Recorded ritual: ${ritual.ritualType}`);\r\n        } catch (error) {\r\n            console.error('Failed to record ritual:', error);\r\n        }\r\n    }\r\n\r\n    // Get user profile\r\n    async getUserProfile(userId: string): Promise<UserProfile | null> {\r\n        if (!this.isInitialized) return null;\r\n\r\n        try {\r\n            const stored = localStorage.getItem(`user_profile_${userId}`);\r\n            if (stored) {\r\n                const profile = JSON.parse(stored);\r\n                profile.lastActive = new Date(profile.lastActive);\r\n                return profile;\r\n            }\r\n            return null;\r\n        } catch (error) {\r\n            console.error('Failed to get user profile:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Update user profile\r\n    async updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const existing = await this.getUserProfile(userId);\r\n            const updated = { ...existing, ...updates, lastActive: new Date() };\r\n\r\n            localStorage.setItem(`user_profile_${userId}`, JSON.stringify(updated));\r\n            console.log(`ðŸ§  Updated user profile for ${userId}`);\r\n        } catch (error) {\r\n            console.error('Failed to update user profile:', error);\r\n        }\r\n    }\r\n\r\n    // Get all gods' memories (for pantheon view)\r\n    async getAllGodMemories(): Promise<GodMemory[]> {\r\n        if (!this.isInitialized) return [];\r\n\r\n        try {\r\n            const memories: GodMemory[] = [];\r\n            for (let i = 0; i < localStorage.length; i++) {\r\n                const key = localStorage.key(i);\r\n                if (key?.startsWith('god_memory_')) {\r\n                    const memory = await this.getGodMemory(key.replace('god_memory_', ''));\r\n                    if (memory) memories.push(memory);\r\n                }\r\n            }\r\n            return memories;\r\n        } catch (error) {\r\n            console.error('Failed to get all god memories:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    // Clear all data (for testing)\r\n    async clearAllData(): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            // Clear all god memories\r\n            for (let i = localStorage.length - 1; i >= 0; i--) {\r\n                const key = localStorage.key(i);\r\n                if (key?.startsWith('god_memory_') || key?.startsWith('user_profile_') || key === 'rituals') {\r\n                    localStorage.removeItem(key);\r\n                }\r\n            }\r\n            console.log('ðŸ§  Cleared all memory data');\r\n        } catch (error) {\r\n            console.error('Failed to clear data:', error);\r\n        }\r\n    }\r\n}\r\n\r\n// Export singleton instance\r\nexport const memoryService = new MemoryService();\r\nexport default memoryService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}