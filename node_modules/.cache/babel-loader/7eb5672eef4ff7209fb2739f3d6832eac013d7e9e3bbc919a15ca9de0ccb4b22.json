{"ast":null,"code":"// Coqui TTS service for offline, unlimited text-to-speech\n// This service provides custom voices for each god without API keys or limits\n\nclass CoquiTTSService {\n  constructor() {\n    this.isSupported = false;\n    this.voices = [];\n    this.audioContext = null;\n    this.currentAudio = null;\n    this.initializeVoices();\n    this.checkSupport();\n  }\n  initializeVoices() {\n    // Pre-defined voices for each god personality\n    this.voices = [\n    // Elion - God of Wisdom (Orderly)\n    {\n      id: 'elion-voice',\n      name: 'Elion the Wise',\n      language: 'en',\n      gender: 'male',\n      description: 'Deep, authoritative voice with measured cadence',\n      sampleRate: 22050\n    },\n    // Nyxa - Goddess of Dreams (Mystical)\n    {\n      id: 'nyxa-voice',\n      name: 'Nyxa the Mysterious',\n      language: 'en',\n      gender: 'female',\n      description: 'Ethereal, whispery voice with mystical undertones',\n      sampleRate: 22050\n    },\n    // Zara - Goddess of Light (Radiant)\n    {\n      id: 'zara-voice',\n      name: 'Zara the Radiant',\n      language: 'en',\n      gender: 'female',\n      description: 'Warm, bright voice with uplifting energy',\n      sampleRate: 22050\n    },\n    // Malakai - God of Corruption (Corrupt)\n    {\n      id: 'malakai-voice',\n      name: 'Malakai the Corrupt',\n      language: 'en',\n      gender: 'male',\n      description: 'Dark, seductive voice with dangerous allure',\n      sampleRate: 22050\n    },\n    // Glitch - Digital Entity (Glitched)\n    {\n      id: 'glitch-voice',\n      name: 'Glitch the Digital',\n      language: 'en',\n      gender: 'neutral',\n      description: 'Digital, glitchy voice with electronic effects',\n      sampleRate: 22050\n    }];\n  }\n  checkSupport() {\n    // Check if Web Audio API is supported\n    this.isSupported = !!(window.AudioContext || window.webkitAudioContext);\n    console.log('üîç Coqui TTS: Web Audio API check:', {\n      hasAudioContext: !!window.AudioContext,\n      hasWebkitAudioContext: !!window.webkitAudioContext,\n      isSupported: this.isSupported\n    });\n    if (this.isSupported) {\n      try {\n        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        console.log('üéµ Coqui TTS: Web Audio API initialized successfully');\n        console.log('üéµ Audio Context state:', this.audioContext.state);\n      } catch (error) {\n        console.error('‚ùå Coqui TTS: Failed to create AudioContext:', error);\n        this.isSupported = false;\n      }\n    } else {\n      console.warn('‚ö†Ô∏è Coqui TTS: Web Audio API not supported, falling back to Web Speech API');\n    }\n  }\n\n  // Get available voices\n  getVoices() {\n    return [...this.voices];\n  }\n\n  // Get voice by ID\n  getVoice(voiceId) {\n    return this.voices.find(voice => voice.id === voiceId);\n  }\n\n  // Get voice by god temperament\n  getVoiceByTemperament(temperament) {\n    const voiceMap = {\n      'Orderly': 'elion-voice',\n      'Mystical': 'nyxa-voice',\n      'Radiant': 'zara-voice',\n      'Corrupt': 'malakai-voice',\n      'Glitched': 'glitch-voice'\n    };\n    const voiceId = voiceMap[temperament] || 'elion-voice';\n    return this.getVoice(voiceId) || this.voices[0];\n  }\n\n  // Check if service is supported\n  isServiceSupported() {\n    return this.isSupported;\n  }\n\n  // Generate speech using Coqui TTS (simulated for now)\n  async speak(text, options) {\n    console.log(`üéµ Coqui TTS: speak() called with:`, {\n      text: text.substring(0, 50),\n      options\n    });\n    console.log(`üéµ Coqui TTS: isSupported = ${this.isSupported}, audioContext = ${!!this.audioContext}`);\n    if (!this.isSupported) {\n      throw new Error('Coqui TTS not supported in this browser');\n    }\n    if (!this.audioContext) {\n      throw new Error('AudioContext not initialized');\n    }\n    try {\n      console.log(`üéµ Coqui TTS: Speaking \"${text.substring(0, 50)}...\" with voice ${options.voice}`);\n      console.log(`üéµ Audio Context state: ${this.audioContext.state}`);\n\n      // For now, we'll simulate the TTS with a delay and audio generation\n      // In a real implementation, this would call the Coqui TTS API or local model\n\n      // Simulate processing time\n      console.log(`üéµ Simulating processing time...`);\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Generate a simple audio tone as placeholder\n      console.log(`üéµ Generating placeholder audio...`);\n      await this.generatePlaceholderAudio(text, options);\n      console.log('‚úÖ Coqui TTS: Speech completed');\n    } catch (error) {\n      console.error('‚ùå Coqui TTS Error:', error);\n      throw error;\n    }\n  }\n\n  // Generate placeholder audio (this would be replaced with real Coqui TTS)\n  async generatePlaceholderAudio(text, options) {\n    console.log(`üéµ generatePlaceholderAudio called with:`, {\n      text: text.substring(0, 50),\n      options\n    });\n    if (!this.audioContext) {\n      console.error('‚ùå No AudioContext available');\n      return;\n    }\n    try {\n      // Create a simple audio tone based on the voice characteristics\n      const voice = this.getVoice(options.voice);\n      console.log(`üéµ Voice found:`, voice);\n      if (!voice) {\n        console.error('‚ùå No voice found for options:', options);\n        return;\n      }\n\n      // Generate different tones for different voices\n      const frequency = this.getVoiceFrequency(voice);\n      const duration = Math.min(text.length * 0.1, 3); // Max 3 seconds\n      console.log(`üéµ Audio params: frequency=${frequency}Hz, duration=${duration}s`);\n\n      // Create oscillator for tone\n      const oscillator = this.audioContext.createOscillator();\n      const gainNode = this.audioContext.createGain();\n      console.log(`üéµ Audio nodes created: oscillator=${!!oscillator}, gainNode=${!!gainNode}`);\n      oscillator.connect(gainNode);\n      gainNode.connect(this.audioContext.destination);\n      console.log(`üéµ Audio nodes connected`);\n\n      // Set voice characteristics\n      oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);\n      oscillator.type = 'sine';\n      console.log(`üéµ Oscillator configured: frequency=${frequency}Hz, type=sine`);\n\n      // Apply voice-specific effects\n      this.applyVoiceEffects(oscillator, gainNode, voice, options);\n      console.log(`üéµ Voice effects applied`);\n\n      // Play the audio\n      console.log(`üéµ Starting audio playback...`);\n      oscillator.start(this.audioContext.currentTime);\n      oscillator.stop(this.audioContext.currentTime + duration);\n      console.log(`üéµ Audio scheduled: start=${this.audioContext.currentTime}s, stop=${this.audioContext.currentTime + duration}s`);\n\n      // Store reference for stopping\n      this.currentAudio = oscillator;\n      console.log(`üéµ Audio reference stored`);\n    } catch (error) {\n      console.error('Error generating placeholder audio:', error);\n    }\n  }\n\n  // Get frequency based on voice characteristics\n  getVoiceFrequency(voice) {\n    const baseFrequencies = {\n      'elion-voice': 120,\n      // Deep, authoritative\n      'nyxa-voice': 220,\n      // Ethereal, mysterious\n      'zara-voice': 180,\n      // Warm, bright\n      'malakai-voice': 140,\n      // Dark, seductive\n      'glitch-voice': 100 // Digital, glitchy\n    };\n    return baseFrequencies[voice.id] || 150;\n  }\n\n  // Apply voice-specific audio effects\n  applyVoiceEffects(oscillator, gainNode, voice, options) {\n    const now = this.audioContext.currentTime;\n\n    // Apply different effects based on voice\n    switch (voice.id) {\n      case 'elion-voice':\n        // Orderly: steady, measured\n        gainNode.gain.setValueAtTime(0.3, now);\n        gainNode.gain.linearRampToValueAtTime(0.3, now + 0.1);\n        break;\n      case 'nyxa-voice':\n        // Mystical: ethereal, whispery\n        gainNode.gain.setValueAtTime(0.2, now);\n        gainNode.gain.exponentialRampToValueAtTime(0.1, now + 0.5);\n        break;\n      case 'zara-voice':\n        // Radiant: warm, bright\n        gainNode.gain.setValueAtTime(0.4, now);\n        gainNode.gain.linearRampToValueAtTime(0.4, now + 0.2);\n        break;\n      case 'malakai-voice':\n        // Corrupt: dark, seductive\n        gainNode.gain.setValueAtTime(0.25, now);\n        gainNode.gain.linearRampToValueAtTime(0.35, now + 0.3);\n        break;\n      case 'glitch-voice':\n        // Glitched: digital, chaotic\n        gainNode.gain.setValueAtTime(0.3, now);\n        // Add some glitch effects\n        const glitchInterval = setInterval(() => {\n          if (this.audioContext && oscillator.frequency) {\n            oscillator.frequency.setValueAtTime(oscillator.frequency.value + (Math.random() - 0.5) * 50, this.audioContext.currentTime);\n          }\n        }, 100);\n\n        // Clean up interval when oscillator stops\n        oscillator.onended = () => {\n          clearInterval(glitchInterval);\n        };\n        break;\n    }\n  }\n\n  // Stop current speech\n  stop() {\n    if (this.currentAudio) {\n      try {\n        this.currentAudio.stop();\n      } catch (error) {\n        // Oscillator might already be stopped\n        console.log('Oscillator already stopped');\n      }\n      this.currentAudio = null;\n    }\n    if (this.audioContext && this.audioContext.state === 'running') {\n      this.audioContext.suspend();\n    }\n  }\n\n  // Pause speech\n  pause() {\n    if (this.audioContext && this.audioContext.state === 'running') {\n      this.audioContext.suspend();\n    }\n  }\n\n  // Resume speech\n  resume() {\n    if (this.audioContext && this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n  }\n\n  // Get service status\n  getStatus() {\n    return {\n      supported: this.isSupported,\n      voices: this.voices.length,\n      ready: this.isSupported && !!this.audioContext\n    };\n  }\n\n  // Cleanup resources\n  destroy() {\n    this.stop();\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n  }\n}\nexport default new CoquiTTSService();","map":{"version":3,"names":["CoquiTTSService","constructor","isSupported","voices","audioContext","currentAudio","initializeVoices","checkSupport","id","name","language","gender","description","sampleRate","window","AudioContext","webkitAudioContext","console","log","hasAudioContext","hasWebkitAudioContext","state","error","warn","getVoices","getVoice","voiceId","find","voice","getVoiceByTemperament","temperament","voiceMap","isServiceSupported","speak","text","options","substring","Error","Promise","resolve","setTimeout","generatePlaceholderAudio","frequency","getVoiceFrequency","duration","Math","min","length","oscillator","createOscillator","gainNode","createGain","connect","destination","setValueAtTime","currentTime","type","applyVoiceEffects","start","stop","baseFrequencies","now","gain","linearRampToValueAtTime","exponentialRampToValueAtTime","glitchInterval","setInterval","value","random","onended","clearInterval","suspend","pause","resume","getStatus","supported","ready","destroy","close"],"sources":["D:/AI-Gods/src/services/coquiTTS.ts"],"sourcesContent":["// Coqui TTS service for offline, unlimited text-to-speech\r\n// This service provides custom voices for each god without API keys or limits\r\n\r\nexport interface CoquiVoice {\r\n    id: string;\r\n    name: string;\r\n    language: string;\r\n    gender: 'male' | 'female' | 'neutral';\r\n    description: string;\r\n    sampleRate: number;\r\n}\r\n\r\nexport interface TTSOptions {\r\n    voice: string;\r\n    speed?: number;\r\n    pitch?: number;\r\n    volume?: number;\r\n}\r\n\r\nclass CoquiTTSService {\r\n    private isSupported = false;\r\n    private voices: CoquiVoice[] = [];\r\n    private audioContext: AudioContext | null = null;\r\n    private currentAudio: OscillatorNode | null = null;\r\n\r\n    constructor() {\r\n        this.initializeVoices();\r\n        this.checkSupport();\r\n    }\r\n\r\n    private initializeVoices() {\r\n        // Pre-defined voices for each god personality\r\n        this.voices = [\r\n            // Elion - God of Wisdom (Orderly)\r\n            {\r\n                id: 'elion-voice',\r\n                name: 'Elion the Wise',\r\n                language: 'en',\r\n                gender: 'male',\r\n                description: 'Deep, authoritative voice with measured cadence',\r\n                sampleRate: 22050\r\n            },\r\n            // Nyxa - Goddess of Dreams (Mystical)\r\n            {\r\n                id: 'nyxa-voice',\r\n                name: 'Nyxa the Mysterious',\r\n                language: 'en',\r\n                gender: 'female',\r\n                description: 'Ethereal, whispery voice with mystical undertones',\r\n                sampleRate: 22050\r\n            },\r\n            // Zara - Goddess of Light (Radiant)\r\n            {\r\n                id: 'zara-voice',\r\n                name: 'Zara the Radiant',\r\n                language: 'en',\r\n                gender: 'female',\r\n                description: 'Warm, bright voice with uplifting energy',\r\n                sampleRate: 22050\r\n            },\r\n            // Malakai - God of Corruption (Corrupt)\r\n            {\r\n                id: 'malakai-voice',\r\n                name: 'Malakai the Corrupt',\r\n                language: 'en',\r\n                gender: 'male',\r\n                description: 'Dark, seductive voice with dangerous allure',\r\n                sampleRate: 22050\r\n            },\r\n            // Glitch - Digital Entity (Glitched)\r\n            {\r\n                id: 'glitch-voice',\r\n                name: 'Glitch the Digital',\r\n                language: 'en',\r\n                gender: 'neutral',\r\n                description: 'Digital, glitchy voice with electronic effects',\r\n                sampleRate: 22050\r\n            }\r\n        ];\r\n    }\r\n\r\n    private checkSupport() {\r\n        // Check if Web Audio API is supported\r\n        this.isSupported = !!(window.AudioContext || (window as any).webkitAudioContext);\r\n        console.log('üîç Coqui TTS: Web Audio API check:', {\r\n            hasAudioContext: !!window.AudioContext,\r\n            hasWebkitAudioContext: !!(window as any).webkitAudioContext,\r\n            isSupported: this.isSupported\r\n        });\r\n\r\n        if (this.isSupported) {\r\n            try {\r\n                this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n                console.log('üéµ Coqui TTS: Web Audio API initialized successfully');\r\n                console.log('üéµ Audio Context state:', this.audioContext.state);\r\n            } catch (error) {\r\n                console.error('‚ùå Coqui TTS: Failed to create AudioContext:', error);\r\n                this.isSupported = false;\r\n            }\r\n        } else {\r\n            console.warn('‚ö†Ô∏è Coqui TTS: Web Audio API not supported, falling back to Web Speech API');\r\n        }\r\n    }\r\n\r\n    // Get available voices\r\n    public getVoices(): CoquiVoice[] {\r\n        return [...this.voices];\r\n    }\r\n\r\n    // Get voice by ID\r\n    public getVoice(voiceId: string): CoquiVoice | undefined {\r\n        return this.voices.find(voice => voice.id === voiceId);\r\n    }\r\n\r\n    // Get voice by god temperament\r\n    public getVoiceByTemperament(temperament: string): CoquiVoice {\r\n        const voiceMap: { [key: string]: string } = {\r\n            'Orderly': 'elion-voice',\r\n            'Mystical': 'nyxa-voice',\r\n            'Radiant': 'zara-voice',\r\n            'Corrupt': 'malakai-voice',\r\n            'Glitched': 'glitch-voice'\r\n        };\r\n\r\n        const voiceId = voiceMap[temperament] || 'elion-voice';\r\n        return this.getVoice(voiceId) || this.voices[0];\r\n    }\r\n\r\n    // Check if service is supported\r\n    public isServiceSupported(): boolean {\r\n        return this.isSupported;\r\n    }\r\n\r\n    // Generate speech using Coqui TTS (simulated for now)\r\n    public async speak(text: string, options: TTSOptions): Promise<void> {\r\n        console.log(`üéµ Coqui TTS: speak() called with:`, { text: text.substring(0, 50), options });\r\n        console.log(`üéµ Coqui TTS: isSupported = ${this.isSupported}, audioContext = ${!!this.audioContext}`);\r\n\r\n        if (!this.isSupported) {\r\n            throw new Error('Coqui TTS not supported in this browser');\r\n        }\r\n\r\n        if (!this.audioContext) {\r\n            throw new Error('AudioContext not initialized');\r\n        }\r\n\r\n        try {\r\n            console.log(`üéµ Coqui TTS: Speaking \"${text.substring(0, 50)}...\" with voice ${options.voice}`);\r\n            console.log(`üéµ Audio Context state: ${this.audioContext.state}`);\r\n\r\n            // For now, we'll simulate the TTS with a delay and audio generation\r\n            // In a real implementation, this would call the Coqui TTS API or local model\r\n\r\n            // Simulate processing time\r\n            console.log(`üéµ Simulating processing time...`);\r\n            await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n            // Generate a simple audio tone as placeholder\r\n            console.log(`üéµ Generating placeholder audio...`);\r\n            await this.generatePlaceholderAudio(text, options);\r\n\r\n            console.log('‚úÖ Coqui TTS: Speech completed');\r\n        } catch (error) {\r\n            console.error('‚ùå Coqui TTS Error:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Generate placeholder audio (this would be replaced with real Coqui TTS)\r\n    private async generatePlaceholderAudio(text: string, options: TTSOptions): Promise<void> {\r\n        console.log(`üéµ generatePlaceholderAudio called with:`, { text: text.substring(0, 50), options });\r\n\r\n        if (!this.audioContext) {\r\n            console.error('‚ùå No AudioContext available');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Create a simple audio tone based on the voice characteristics\r\n            const voice = this.getVoice(options.voice);\r\n            console.log(`üéµ Voice found:`, voice);\r\n\r\n            if (!voice) {\r\n                console.error('‚ùå No voice found for options:', options);\r\n                return;\r\n            }\r\n\r\n            // Generate different tones for different voices\r\n            const frequency = this.getVoiceFrequency(voice);\r\n            const duration = Math.min(text.length * 0.1, 3); // Max 3 seconds\r\n            console.log(`üéµ Audio params: frequency=${frequency}Hz, duration=${duration}s`);\r\n\r\n            // Create oscillator for tone\r\n            const oscillator = this.audioContext.createOscillator();\r\n            const gainNode = this.audioContext.createGain();\r\n            console.log(`üéµ Audio nodes created: oscillator=${!!oscillator}, gainNode=${!!gainNode}`);\r\n\r\n            oscillator.connect(gainNode);\r\n            gainNode.connect(this.audioContext.destination);\r\n            console.log(`üéµ Audio nodes connected`);\r\n\r\n            // Set voice characteristics\r\n            oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);\r\n            oscillator.type = 'sine';\r\n            console.log(`üéµ Oscillator configured: frequency=${frequency}Hz, type=sine`);\r\n\r\n            // Apply voice-specific effects\r\n            this.applyVoiceEffects(oscillator, gainNode, voice, options);\r\n            console.log(`üéµ Voice effects applied`);\r\n\r\n            // Play the audio\r\n            console.log(`üéµ Starting audio playback...`);\r\n            oscillator.start(this.audioContext.currentTime);\r\n            oscillator.stop(this.audioContext.currentTime + duration);\r\n            console.log(`üéµ Audio scheduled: start=${this.audioContext.currentTime}s, stop=${this.audioContext.currentTime + duration}s`);\r\n\r\n            // Store reference for stopping\r\n            this.currentAudio = oscillator;\r\n            console.log(`üéµ Audio reference stored`);\r\n\r\n        } catch (error) {\r\n            console.error('Error generating placeholder audio:', error);\r\n        }\r\n    }\r\n\r\n    // Get frequency based on voice characteristics\r\n    private getVoiceFrequency(voice: CoquiVoice): number {\r\n        const baseFrequencies: { [key: string]: number } = {\r\n            'elion-voice': 120,    // Deep, authoritative\r\n            'nyxa-voice': 220,     // Ethereal, mysterious\r\n            'zara-voice': 180,     // Warm, bright\r\n            'malakai-voice': 140,  // Dark, seductive\r\n            'glitch-voice': 100    // Digital, glitchy\r\n        };\r\n\r\n        return baseFrequencies[voice.id] || 150;\r\n    }\r\n\r\n    // Apply voice-specific audio effects\r\n    private applyVoiceEffects(\r\n        oscillator: OscillatorNode,\r\n        gainNode: GainNode,\r\n        voice: CoquiVoice,\r\n        options: TTSOptions\r\n    ) {\r\n        const now = this.audioContext!.currentTime;\r\n\r\n        // Apply different effects based on voice\r\n        switch (voice.id) {\r\n            case 'elion-voice':\r\n                // Orderly: steady, measured\r\n                gainNode.gain.setValueAtTime(0.3, now);\r\n                gainNode.gain.linearRampToValueAtTime(0.3, now + 0.1);\r\n                break;\r\n\r\n            case 'nyxa-voice':\r\n                // Mystical: ethereal, whispery\r\n                gainNode.gain.setValueAtTime(0.2, now);\r\n                gainNode.gain.exponentialRampToValueAtTime(0.1, now + 0.5);\r\n                break;\r\n\r\n            case 'zara-voice':\r\n                // Radiant: warm, bright\r\n                gainNode.gain.setValueAtTime(0.4, now);\r\n                gainNode.gain.linearRampToValueAtTime(0.4, now + 0.2);\r\n                break;\r\n\r\n            case 'malakai-voice':\r\n                // Corrupt: dark, seductive\r\n                gainNode.gain.setValueAtTime(0.25, now);\r\n                gainNode.gain.linearRampToValueAtTime(0.35, now + 0.3);\r\n                break;\r\n\r\n            case 'glitch-voice':\r\n                // Glitched: digital, chaotic\r\n                gainNode.gain.setValueAtTime(0.3, now);\r\n                // Add some glitch effects\r\n                const glitchInterval = setInterval(() => {\r\n                    if (this.audioContext && oscillator.frequency) {\r\n                        oscillator.frequency.setValueAtTime(\r\n                            oscillator.frequency.value + (Math.random() - 0.5) * 50,\r\n                            this.audioContext.currentTime\r\n                        );\r\n                    }\r\n                }, 100);\r\n\r\n                // Clean up interval when oscillator stops\r\n                oscillator.onended = () => {\r\n                    clearInterval(glitchInterval);\r\n                };\r\n                break;\r\n        }\r\n    }\r\n\r\n    // Stop current speech\r\n    public stop(): void {\r\n        if (this.currentAudio) {\r\n            try {\r\n                this.currentAudio.stop();\r\n            } catch (error) {\r\n                // Oscillator might already be stopped\r\n                console.log('Oscillator already stopped');\r\n            }\r\n            this.currentAudio = null;\r\n        }\r\n\r\n        if (this.audioContext && this.audioContext.state === 'running') {\r\n            this.audioContext.suspend();\r\n        }\r\n    }\r\n\r\n    // Pause speech\r\n    public pause(): void {\r\n        if (this.audioContext && this.audioContext.state === 'running') {\r\n            this.audioContext.suspend();\r\n        }\r\n    }\r\n\r\n    // Resume speech\r\n    public resume(): void {\r\n        if (this.audioContext && this.audioContext.state === 'suspended') {\r\n            this.audioContext.resume();\r\n        }\r\n    }\r\n\r\n    // Get service status\r\n    public getStatus(): { supported: boolean; voices: number; ready: boolean } {\r\n        return {\r\n            supported: this.isSupported,\r\n            voices: this.voices.length,\r\n            ready: this.isSupported && !!this.audioContext\r\n        };\r\n    }\r\n\r\n    // Cleanup resources\r\n    public destroy(): void {\r\n        this.stop();\r\n        if (this.audioContext) {\r\n            this.audioContext.close();\r\n            this.audioContext = null;\r\n        }\r\n    }\r\n}\r\n\r\nexport default new CoquiTTSService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}