{"ast":null,"code":"import _objectSpread from\"D:/AI-Gods/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";class MemoryService{constructor(){this.db=void 0;// Will be SQLite database\nthis.isInitialized=false;this.initializeDatabase();}async initializeDatabase(){try{// For now, we'll use localStorage as a fallback\n// Later we'll integrate with actual SQLite\nthis.isInitialized=true;console.log('ðŸ§  Memory Service initialized');}catch(error){console.error('Failed to initialize memory service:',error);}}// Create or update god memory\nasync updateGodMemory(godId,memory){if(!this.isInitialized)return;try{const existing=await this.getGodMemory(godId);const updated=_objectSpread(_objectSpread({},existing),memory);// Store in localStorage for now\nlocalStorage.setItem(\"god_memory_\".concat(godId),JSON.stringify(updated));console.log(\"\\uD83E\\uDDE0 Updated memory for \".concat(godId));}catch(error){console.error('Failed to update god memory:',error);}}// Get god's memory\nasync getGodMemory(godId){if(!this.isInitialized)return null;try{const stored=localStorage.getItem(\"god_memory_\".concat(godId));if(stored){const memory=JSON.parse(stored);// Convert timestamp strings back to Date objects\nmemory.memories=memory.memories.map(m=>_objectSpread(_objectSpread({},m),{},{timestamp:new Date(m.timestamp)}));return memory;}return null;}catch(error){console.error('Failed to get god memory:',error);return null;}}// Add a new memory entry\nasync addMemory(godId,memory){if(!this.isInitialized)return;try{const godMemory=await this.getGodMemory(godId);if(!godMemory)return;const newMemory=_objectSpread(_objectSpread({},memory),{},{id:\"mem_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9)),timestamp:new Date()});godMemory.memories.push(newMemory);// Keep only last 100 memories to prevent bloat\nif(godMemory.memories.length>100){godMemory.memories=godMemory.memories.sort((a,b)=>b.importance-a.importance).slice(0,100);}await this.updateGodMemory(godId,godMemory);console.log(\"\\uD83E\\uDDE0 Added memory to \".concat(godId,\": \").concat(memory.content.substring(0,50),\"...\"));}catch(error){console.error('Failed to add memory:',error);}}// Get relevant memories for context\nasync getRelevantMemories(godId,query){let limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:5;if(!this.isInitialized)return[];try{const godMemory=await this.getGodMemory(godId);if(!godMemory)return[];// Simple relevance scoring based on content and tags\nconst scored=godMemory.memories.map(memory=>{let score=memory.importance;// Boost score if query matches content or tags\nif(memory.content.toLowerCase().includes(query.toLowerCase()))score+=5;if(memory.tags.some(tag=>tag.toLowerCase().includes(query.toLowerCase())))score+=3;return{memory,score};});// Return top memories by score\nreturn scored.sort((a,b)=>b.score-a.score).slice(0,limit).map(item=>item.memory);}catch(error){console.error('Failed to get relevant memories:',error);return[];}}// Update god's personality based on interactions\nasync updatePersonality(godId,changes){if(!this.isInitialized)return;try{const godMemory=await this.getGodMemory(godId);if(!godMemory)return;godMemory.personality=_objectSpread(_objectSpread({},godMemory.personality),changes);await this.updateGodMemory(godId,godMemory);console.log(\"\\uD83E\\uDDE0 Updated personality for \".concat(godId));}catch(error){console.error('Failed to update personality:',error);}}// Record a ritual\nasync recordRitual(ritual){if(!this.isInitialized)return;try{const newRitual=_objectSpread(_objectSpread({},ritual),{},{id:\"ritual_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9)),timestamp:new Date()});// Store ritual in localStorage\nconst rituals=JSON.parse(localStorage.getItem('rituals')||'[]');rituals.push(newRitual);localStorage.setItem('rituals',JSON.stringify(rituals));console.log(\"\\uD83E\\uDDE0 Recorded ritual: \".concat(ritual.ritualType));}catch(error){console.error('Failed to record ritual:',error);}}// Get user profile\nasync getUserProfile(userId){if(!this.isInitialized)return null;try{const stored=localStorage.getItem(\"user_profile_\".concat(userId));if(stored){const profile=JSON.parse(stored);profile.lastActive=new Date(profile.lastActive);return profile;}return null;}catch(error){console.error('Failed to get user profile:',error);return null;}}// Update user profile\nasync updateUserProfile(userId,updates){if(!this.isInitialized)return;try{const existing=await this.getUserProfile(userId);const updated=_objectSpread(_objectSpread(_objectSpread({},existing),updates),{},{lastActive:new Date()});localStorage.setItem(\"user_profile_\".concat(userId),JSON.stringify(updated));console.log(\"\\uD83E\\uDDE0 Updated user profile for \".concat(userId));}catch(error){console.error('Failed to update user profile:',error);}}// Get all gods' memories (for pantheon view)\nasync getAllGodMemories(){if(!this.isInitialized)return[];try{const memories=[];for(let i=0;i<localStorage.length;i++){const key=localStorage.key(i);if(key!==null&&key!==void 0&&key.startsWith('god_memory_')){const memory=await this.getGodMemory(key.replace('god_memory_',''));if(memory)memories.push(memory);}}return memories;}catch(error){console.error('Failed to get all god memories:',error);return[];}}// Clear all data (for testing)\nasync clearAllData(){if(!this.isInitialized)return;try{// Clear all god memories\nfor(let i=localStorage.length-1;i>=0;i--){const key=localStorage.key(i);if(key!==null&&key!==void 0&&key.startsWith('god_memory_')||key!==null&&key!==void 0&&key.startsWith('user_profile_')||key==='rituals'){localStorage.removeItem(key);}}console.log('ðŸ§  Cleared all memory data');}catch(error){console.error('Failed to clear data:',error);}}}// Export singleton instance\nexport const memoryService=new MemoryService();export default memoryService;","map":{"version":3,"names":["MemoryService","constructor","db","isInitialized","initializeDatabase","console","log","error","updateGodMemory","godId","memory","existing","getGodMemory","updated","_objectSpread","localStorage","setItem","concat","JSON","stringify","stored","getItem","parse","memories","map","m","timestamp","Date","addMemory","godMemory","newMemory","id","now","Math","random","toString","substr","push","length","sort","a","b","importance","slice","content","substring","getRelevantMemories","query","limit","arguments","undefined","scored","score","toLowerCase","includes","tags","some","tag","item","updatePersonality","changes","personality","recordRitual","ritual","newRitual","rituals","ritualType","getUserProfile","userId","profile","lastActive","updateUserProfile","updates","getAllGodMemories","i","key","startsWith","replace","clearAllData","removeItem","memoryService"],"sources":["D:/AI-Gods/src/services/memory.ts"],"sourcesContent":["export interface MemoryEntry {\r\n    id: string;\r\n    timestamp: Date;\r\n    type: 'conversation' | 'offering' | 'ritual' | 'lore' | 'interaction';\r\n    content: string;\r\n    metadata: Record<string, any>;\r\n    importance: number; // 1-10, how important this memory is\r\n    tags: string[];\r\n}\r\n\r\nexport interface GodMemory {\r\n    godId: string;\r\n    godName: string;\r\n    domain: string;\r\n    temperament: string;\r\n    memories: MemoryEntry[];\r\n    personality: {\r\n        currentMood: string;\r\n        relationshipWithUser: number; // -100 to 100\r\n        knowledgeLevel: number; // 1-100\r\n        corruptionLevel: number; // 0-100\r\n        specialAbilities: string[];\r\n    };\r\n    lore: {\r\n        creationDate: Date;\r\n        domains: string[];\r\n        sacredRules: string[];\r\n        taboos: string[];\r\n        allies: string[];\r\n        enemies: string[];\r\n        achievements: string[];\r\n    };\r\n    sessions: {\r\n        totalSessions: number;\r\n        lastSession: Date;\r\n        favoriteTopics: string[];\r\n        userPreferences: Record<string, any>;\r\n    };\r\n}\r\n\r\nexport interface RitualMemory {\r\n    id: string;\r\n    timestamp: Date;\r\n    ritualType: string;\r\n    participants: string[];\r\n    outcome: string;\r\n    effects: string[];\r\n    offerings: string[];\r\n    divineResponse: string;\r\n}\r\n\r\nexport interface UserProfile {\r\n    userId: string;\r\n    username: string;\r\n    divineStanding: number;\r\n    favoriteGods: string[];\r\n    completedRituals: RitualMemory[];\r\n    offerings: string[];\r\n    achievements: string[];\r\n    lastActive: Date;\r\n}\r\n\r\nclass MemoryService {\r\n    private db: any; // Will be SQLite database\r\n    private isInitialized = false;\r\n\r\n    constructor() {\r\n        this.initializeDatabase();\r\n    }\r\n\r\n    private async initializeDatabase() {\r\n        try {\r\n            // For now, we'll use localStorage as a fallback\r\n            // Later we'll integrate with actual SQLite\r\n            this.isInitialized = true;\r\n            console.log('ðŸ§  Memory Service initialized');\r\n        } catch (error) {\r\n            console.error('Failed to initialize memory service:', error);\r\n        }\r\n    }\r\n\r\n    // Create or update god memory\r\n    async updateGodMemory(godId: string, memory: Partial<GodMemory>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const existing = await this.getGodMemory(godId);\r\n            const updated = { ...existing, ...memory };\r\n\r\n            // Store in localStorage for now\r\n            localStorage.setItem(`god_memory_${godId}`, JSON.stringify(updated));\r\n\r\n            console.log(`ðŸ§  Updated memory for ${godId}`);\r\n        } catch (error) {\r\n            console.error('Failed to update god memory:', error);\r\n        }\r\n    }\r\n\r\n    // Get god's memory\r\n    async getGodMemory(godId: string): Promise<GodMemory | null> {\r\n        if (!this.isInitialized) return null;\r\n\r\n        try {\r\n            const stored = localStorage.getItem(`god_memory_${godId}`);\r\n            if (stored) {\r\n                const memory = JSON.parse(stored);\r\n                // Convert timestamp strings back to Date objects\r\n                memory.memories = memory.memories.map((m: any) => ({\r\n                    ...m,\r\n                    timestamp: new Date(m.timestamp)\r\n                }));\r\n                return memory;\r\n            }\r\n            return null;\r\n        } catch (error) {\r\n            console.error('Failed to get god memory:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Add a new memory entry\r\n    async addMemory(godId: string, memory: Omit<MemoryEntry, 'id' | 'timestamp'>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const godMemory = await this.getGodMemory(godId);\r\n            if (!godMemory) return;\r\n\r\n            const newMemory: MemoryEntry = {\r\n                ...memory,\r\n                id: `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n                timestamp: new Date()\r\n            };\r\n\r\n            godMemory.memories.push(newMemory);\r\n\r\n            // Keep only last 100 memories to prevent bloat\r\n            if (godMemory.memories.length > 100) {\r\n                godMemory.memories = godMemory.memories\r\n                    .sort((a, b) => b.importance - a.importance)\r\n                    .slice(0, 100);\r\n            }\r\n\r\n            await this.updateGodMemory(godId, godMemory);\r\n            console.log(`ðŸ§  Added memory to ${godId}: ${memory.content.substring(0, 50)}...`);\r\n        } catch (error) {\r\n            console.error('Failed to add memory:', error);\r\n        }\r\n    }\r\n\r\n    // Get relevant memories for context\r\n    async getRelevantMemories(godId: string, query: string, limit: number = 5): Promise<MemoryEntry[]> {\r\n        if (!this.isInitialized) return [];\r\n\r\n        try {\r\n            const godMemory = await this.getGodMemory(godId);\r\n            if (!godMemory) return [];\r\n\r\n            // Simple relevance scoring based on content and tags\r\n            const scored = godMemory.memories.map(memory => {\r\n                let score = memory.importance;\r\n\r\n                // Boost score if query matches content or tags\r\n                if (memory.content.toLowerCase().includes(query.toLowerCase())) score += 5;\r\n                if (memory.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()))) score += 3;\r\n\r\n                return { memory, score };\r\n            });\r\n\r\n            // Return top memories by score\r\n            return scored\r\n                .sort((a, b) => b.score - a.score)\r\n                .slice(0, limit)\r\n                .map(item => item.memory);\r\n        } catch (error) {\r\n            console.error('Failed to get relevant memories:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    // Update god's personality based on interactions\r\n    async updatePersonality(godId: string, changes: Partial<GodMemory['personality']>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const godMemory = await this.getGodMemory(godId);\r\n            if (!godMemory) return;\r\n\r\n            godMemory.personality = { ...godMemory.personality, ...changes };\r\n            await this.updateGodMemory(godId, godMemory);\r\n\r\n            console.log(`ðŸ§  Updated personality for ${godId}`);\r\n        } catch (error) {\r\n            console.error('Failed to update personality:', error);\r\n        }\r\n    }\r\n\r\n    // Record a ritual\r\n    async recordRitual(ritual: Omit<RitualMemory, 'id' | 'timestamp'>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const newRitual: RitualMemory = {\r\n                ...ritual,\r\n                id: `ritual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n                timestamp: new Date()\r\n            };\r\n\r\n            // Store ritual in localStorage\r\n            const rituals = JSON.parse(localStorage.getItem('rituals') || '[]');\r\n            rituals.push(newRitual);\r\n            localStorage.setItem('rituals', JSON.stringify(rituals));\r\n\r\n            console.log(`ðŸ§  Recorded ritual: ${ritual.ritualType}`);\r\n        } catch (error) {\r\n            console.error('Failed to record ritual:', error);\r\n        }\r\n    }\r\n\r\n    // Get user profile\r\n    async getUserProfile(userId: string): Promise<UserProfile | null> {\r\n        if (!this.isInitialized) return null;\r\n\r\n        try {\r\n            const stored = localStorage.getItem(`user_profile_${userId}`);\r\n            if (stored) {\r\n                const profile = JSON.parse(stored);\r\n                profile.lastActive = new Date(profile.lastActive);\r\n                return profile;\r\n            }\r\n            return null;\r\n        } catch (error) {\r\n            console.error('Failed to get user profile:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Update user profile\r\n    async updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            const existing = await this.getUserProfile(userId);\r\n            const updated = { ...existing, ...updates, lastActive: new Date() };\r\n\r\n            localStorage.setItem(`user_profile_${userId}`, JSON.stringify(updated));\r\n            console.log(`ðŸ§  Updated user profile for ${userId}`);\r\n        } catch (error) {\r\n            console.error('Failed to update user profile:', error);\r\n        }\r\n    }\r\n\r\n    // Get all gods' memories (for pantheon view)\r\n    async getAllGodMemories(): Promise<GodMemory[]> {\r\n        if (!this.isInitialized) return [];\r\n\r\n        try {\r\n            const memories: GodMemory[] = [];\r\n            for (let i = 0; i < localStorage.length; i++) {\r\n                const key = localStorage.key(i);\r\n                if (key?.startsWith('god_memory_')) {\r\n                    const memory = await this.getGodMemory(key.replace('god_memory_', ''));\r\n                    if (memory) memories.push(memory);\r\n                }\r\n            }\r\n            return memories;\r\n        } catch (error) {\r\n            console.error('Failed to get all god memories:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    // Clear all data (for testing)\r\n    async clearAllData(): Promise<void> {\r\n        if (!this.isInitialized) return;\r\n\r\n        try {\r\n            // Clear all god memories\r\n            for (let i = localStorage.length - 1; i >= 0; i--) {\r\n                const key = localStorage.key(i);\r\n                if (key?.startsWith('god_memory_') || key?.startsWith('user_profile_') || key === 'rituals') {\r\n                    localStorage.removeItem(key);\r\n                }\r\n            }\r\n            console.log('ðŸ§  Cleared all memory data');\r\n        } catch (error) {\r\n            console.error('Failed to clear data:', error);\r\n        }\r\n    }\r\n}\r\n\r\n// Export singleton instance\r\nexport const memoryService = new MemoryService();\r\nexport default memoryService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}