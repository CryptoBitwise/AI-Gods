{"ast":null,"code":"class PWAService {\n  constructor() {\n    this.deferredPrompt = null;\n    this.isInstalled = false;\n    this.onlineStatus = navigator.onLine;\n    this.updateAvailable = false;\n    this.swRegistration = null;\n    this.initialize();\n  }\n  async initialize() {\n    // Check if app is already installed\n    this.isInstalled = this.checkIfInstalled();\n\n    // Listen for online/offline events\n    window.addEventListener('online', () => this.handleOnline());\n    window.addEventListener('offline', () => this.handleOffline());\n\n    // Listen for beforeinstallprompt event\n    window.addEventListener('beforeinstallprompt', e => {\n      e.preventDefault();\n      this.deferredPrompt = e;\n      this.dispatchEvent('installPromptAvailable');\n    });\n\n    // Listen for app installed event\n    window.addEventListener('appinstalled', () => {\n      this.isInstalled = true;\n      this.deferredPrompt = null;\n      this.dispatchEvent('appInstalled');\n    });\n\n    // Register service worker\n    await this.registerServiceWorker();\n\n    // Check for updates\n    this.checkForUpdates();\n  }\n  checkIfInstalled() {\n    // Check if running in standalone mode (installed PWA)\n    if (window.matchMedia('(display-mode: standalone)').matches) {\n      return true;\n    }\n\n    // Check if running in fullscreen mode\n    if (window.matchMedia('(display-mode: fullscreen)').matches) {\n      return true;\n    }\n\n    // Check if running in minimal-ui mode\n    if (window.matchMedia('(display-mode: minimal-ui)').matches) {\n      return true;\n    }\n    return false;\n  }\n  async registerServiceWorker() {\n    if ('serviceWorker' in navigator) {\n      try {\n        this.swRegistration = await navigator.serviceWorker.register('/sw.js');\n        console.log('‚úÖ Service Worker registered successfully:', this.swRegistration);\n\n        // Listen for service worker updates\n        this.swRegistration.addEventListener('updatefound', () => {\n          const newWorker = this.swRegistration.installing;\n          if (newWorker) {\n            newWorker.addEventListener('statechange', () => {\n              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n                this.updateAvailable = true;\n                this.dispatchEvent('updateAvailable');\n              }\n            });\n          }\n        });\n\n        // Listen for controller change (new service worker activated)\n        navigator.serviceWorker.addEventListener('controllerchange', () => {\n          this.updateAvailable = false;\n          this.dispatchEvent('updateInstalled');\n        });\n      } catch (error) {\n        console.error('‚ùå Service Worker registration failed:', error);\n      }\n    }\n  }\n  handleOnline() {\n    this.isOnline = true;\n    this.dispatchEvent('online');\n\n    // Sync any offline data\n    this.syncOfflineData();\n  }\n  handleOffline() {\n    this.isOnline = false;\n    this.dispatchEvent('offline');\n  }\n  async syncOfflineData() {\n    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\n      try {\n        // Request background sync for offline actions\n        const registration = await navigator.serviceWorker.ready;\n        await registration.sync.register('offline-ritual');\n        console.log('üîÑ Background sync registered for offline rituals');\n      } catch (error) {\n        console.error('‚ùå Background sync registration failed:', error);\n      }\n    }\n  }\n  checkForUpdates() {\n    if (this.swRegistration) {\n      this.swRegistration.update();\n    }\n  }\n\n  // Public methods\n  async installApp() {\n    if (!this.deferredPrompt) {\n      console.log('‚ùå No install prompt available');\n      return false;\n    }\n    try {\n      // Show the install prompt\n      await this.deferredPrompt.prompt();\n\n      // Wait for user choice\n      const choiceResult = await this.deferredPrompt.userChoice;\n      if (choiceResult.outcome === 'accepted') {\n        console.log('‚úÖ App installation accepted');\n        this.deferredPrompt = null;\n        return true;\n      } else {\n        console.log('‚ùå App installation dismissed');\n        return false;\n      }\n    } catch (error) {\n      console.error('‚ùå Install prompt failed:', error);\n      return false;\n    }\n  }\n  async updateApp() {\n    if (this.swRegistration && this.updateAvailable) {\n      try {\n        // Send message to service worker to skip waiting\n        if (this.swRegistration.waiting) {\n          this.swRegistration.waiting.postMessage({\n            type: 'SKIP_WAITING'\n          });\n        }\n\n        // Reload the page to activate new service worker\n        window.location.reload();\n      } catch (error) {\n        console.error('‚ùå App update failed:', error);\n      }\n    }\n  }\n  getInstallPrompt() {\n    if (!this.deferredPrompt) {\n      return null;\n    }\n    return {\n      event: this.deferredPrompt,\n      showPrompt: async () => {\n        await this.installApp();\n      }\n    };\n  }\n  isAppInstallable() {\n    return !this.isInstalled && this.deferredPrompt !== null;\n  }\n  isAppInstalled() {\n    return this.isInstalled;\n  }\n  isOnline() {\n    return this.isOnline;\n  }\n  hasUpdate() {\n    return this.updateAvailable;\n  }\n  getServiceWorkerRegistration() {\n    return this.swRegistration;\n  }\n\n  // Offline functionality\n  async cacheData(key, data) {\n    if ('caches' in window) {\n      try {\n        const cache = await caches.open('ai-gods-data');\n        const response = new Response(JSON.stringify(data));\n        await cache.put(`/data/${key}`, response);\n        console.log('üíæ Data cached successfully:', key);\n      } catch (error) {\n        console.error('‚ùå Failed to cache data:', error);\n      }\n    }\n  }\n  async getCachedData(key) {\n    if ('caches' in window) {\n      try {\n        const cache = await caches.open('ai-gods-data');\n        const response = await cache.match(`/data/${key}`);\n        if (response) {\n          const data = await response.json();\n          console.log('üì¶ Data retrieved from cache:', key);\n          return data;\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to retrieve cached data:', error);\n      }\n    }\n    return null;\n  }\n\n  // Event dispatching\n  dispatchEvent(eventName, data) {\n    const event = new CustomEvent(`pwa:${eventName}`, {\n      detail: data\n    });\n    window.dispatchEvent(event);\n  }\n\n  // Event listening\n  on(eventName, callback) {\n    window.addEventListener(`pwa:${eventName}`, callback);\n  }\n  off(eventName, callback) {\n    window.removeEventListener(`pwa:${eventName}`, callback);\n  }\n\n  // Utility methods\n  async getAppVersion() {\n    if (this.swRegistration && this.swRegistration.active) {\n      try {\n        const messageChannel = new MessageChannel();\n        return new Promise(resolve => {\n          messageChannel.port1.onmessage = event => {\n            resolve(event.data.version);\n          };\n          this.swRegistration.active.postMessage({\n            type: 'GET_VERSION'\n          }, [messageChannel.port2]);\n        });\n      } catch (error) {\n        console.error('‚ùå Failed to get app version:', error);\n        return 'unknown';\n      }\n    }\n    return 'unknown';\n  }\n  async clearCache() {\n    if ('caches' in window) {\n      try {\n        const cacheNames = await caches.keys();\n        await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));\n        console.log('üóëÔ∏è All caches cleared successfully');\n      } catch (error) {\n        console.error('‚ùå Failed to clear caches:', error);\n      }\n    }\n  }\n  async unregisterServiceWorker() {\n    if (this.swRegistration) {\n      try {\n        await this.swRegistration.unregister();\n        this.swRegistration = null;\n        console.log('‚úÖ Service Worker unregistered successfully');\n      } catch (error) {\n        console.error('‚ùå Failed to unregister Service Worker:', error);\n      }\n    }\n  }\n}\n\n// Export singleton instance\nexport const pwaService = new PWAService();\nexport default pwaService;","map":{"version":3,"names":["PWAService","constructor","deferredPrompt","isInstalled","onlineStatus","navigator","onLine","updateAvailable","swRegistration","initialize","checkIfInstalled","window","addEventListener","handleOnline","handleOffline","e","preventDefault","dispatchEvent","registerServiceWorker","checkForUpdates","matchMedia","matches","serviceWorker","register","console","log","newWorker","installing","state","controller","error","isOnline","syncOfflineData","registration","ready","sync","update","installApp","prompt","choiceResult","userChoice","outcome","updateApp","waiting","postMessage","type","location","reload","getInstallPrompt","event","showPrompt","isAppInstallable","isAppInstalled","hasUpdate","getServiceWorkerRegistration","cacheData","key","data","cache","caches","open","response","Response","JSON","stringify","put","getCachedData","match","json","eventName","CustomEvent","detail","on","callback","off","removeEventListener","getAppVersion","active","messageChannel","MessageChannel","Promise","resolve","port1","onmessage","version","port2","clearCache","cacheNames","keys","all","map","cacheName","delete","unregisterServiceWorker","unregister","pwaService"],"sources":["D:/AI-Gods/src/services/pwaService.ts"],"sourcesContent":["interface BeforeInstallPromptEvent extends Event {\r\n  readonly platforms: string[];\r\n  readonly userChoice: Promise<{\r\n    outcome: 'accepted' | 'dismissed';\r\n    platform: string;\r\n  }>;\r\n  prompt(): Promise<void>;\r\n}\r\n\r\ninterface PWAInstallPrompt {\r\n  event: BeforeInstallPromptEvent;\r\n  showPrompt(): Promise<void>;\r\n}\r\n\r\nclass PWAService {\r\n  private deferredPrompt: BeforeInstallPromptEvent | null = null;\r\n  private isInstalled = false;\r\n  private onlineStatus = navigator.onLine;\r\n  private updateAvailable = false;\r\n  private swRegistration: ServiceWorkerRegistration | null = null;\r\n\r\n  constructor() {\r\n    this.initialize();\r\n  }\r\n\r\n  private async initialize() {\r\n    // Check if app is already installed\r\n    this.isInstalled = this.checkIfInstalled();\r\n    \r\n    // Listen for online/offline events\r\n    window.addEventListener('online', () => this.handleOnline());\r\n    window.addEventListener('offline', () => this.handleOffline());\r\n    \r\n    // Listen for beforeinstallprompt event\r\n    window.addEventListener('beforeinstallprompt', (e) => {\r\n      e.preventDefault();\r\n      this.deferredPrompt = e as BeforeInstallPromptEvent;\r\n      this.dispatchEvent('installPromptAvailable');\r\n    });\r\n\r\n    // Listen for app installed event\r\n    window.addEventListener('appinstalled', () => {\r\n      this.isInstalled = true;\r\n      this.deferredPrompt = null;\r\n      this.dispatchEvent('appInstalled');\r\n    });\r\n\r\n    // Register service worker\r\n    await this.registerServiceWorker();\r\n\r\n    // Check for updates\r\n    this.checkForUpdates();\r\n  }\r\n\r\n  private checkIfInstalled(): boolean {\r\n    // Check if running in standalone mode (installed PWA)\r\n    if (window.matchMedia('(display-mode: standalone)').matches) {\r\n      return true;\r\n    }\r\n    \r\n    // Check if running in fullscreen mode\r\n    if (window.matchMedia('(display-mode: fullscreen)').matches) {\r\n      return true;\r\n    }\r\n    \r\n    // Check if running in minimal-ui mode\r\n    if (window.matchMedia('(display-mode: minimal-ui)').matches) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  private async registerServiceWorker(): Promise<void> {\r\n    if ('serviceWorker' in navigator) {\r\n      try {\r\n        this.swRegistration = await navigator.serviceWorker.register('/sw.js');\r\n        console.log('‚úÖ Service Worker registered successfully:', this.swRegistration);\r\n        \r\n        // Listen for service worker updates\r\n        this.swRegistration.addEventListener('updatefound', () => {\r\n          const newWorker = this.swRegistration!.installing;\r\n          if (newWorker) {\r\n            newWorker.addEventListener('statechange', () => {\r\n              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\r\n                this.updateAvailable = true;\r\n                this.dispatchEvent('updateAvailable');\r\n              }\r\n            });\r\n          }\r\n        });\r\n        \r\n        // Listen for controller change (new service worker activated)\r\n        navigator.serviceWorker.addEventListener('controllerchange', () => {\r\n          this.updateAvailable = false;\r\n          this.dispatchEvent('updateInstalled');\r\n        });\r\n        \r\n      } catch (error) {\r\n        console.error('‚ùå Service Worker registration failed:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private handleOnline(): void {\r\n    this.isOnline = true;\r\n    this.dispatchEvent('online');\r\n    \r\n    // Sync any offline data\r\n    this.syncOfflineData();\r\n  }\r\n\r\n  private handleOffline(): void {\r\n    this.isOnline = false;\r\n    this.dispatchEvent('offline');\r\n  }\r\n\r\n  private async syncOfflineData(): Promise<void> {\r\n    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\r\n      try {\r\n        // Request background sync for offline actions\r\n        const registration = await navigator.serviceWorker.ready;\r\n        await registration.sync.register('offline-ritual');\r\n        console.log('üîÑ Background sync registered for offline rituals');\r\n      } catch (error) {\r\n        console.error('‚ùå Background sync registration failed:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private checkForUpdates(): void {\r\n    if (this.swRegistration) {\r\n      this.swRegistration.update();\r\n    }\r\n  }\r\n\r\n  // Public methods\r\n  public async installApp(): Promise<boolean> {\r\n    if (!this.deferredPrompt) {\r\n      console.log('‚ùå No install prompt available');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // Show the install prompt\r\n      await this.deferredPrompt.prompt();\r\n      \r\n      // Wait for user choice\r\n      const choiceResult = await this.deferredPrompt.userChoice;\r\n      \r\n      if (choiceResult.outcome === 'accepted') {\r\n        console.log('‚úÖ App installation accepted');\r\n        this.deferredPrompt = null;\r\n        return true;\r\n      } else {\r\n        console.log('‚ùå App installation dismissed');\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('‚ùå Install prompt failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  public async updateApp(): Promise<void> {\r\n    if (this.swRegistration && this.updateAvailable) {\r\n      try {\r\n        // Send message to service worker to skip waiting\r\n        if (this.swRegistration.waiting) {\r\n          this.swRegistration.waiting.postMessage({ type: 'SKIP_WAITING' });\r\n        }\r\n        \r\n        // Reload the page to activate new service worker\r\n        window.location.reload();\r\n      } catch (error) {\r\n        console.error('‚ùå App update failed:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  public getInstallPrompt(): PWAInstallPrompt | null {\r\n    if (!this.deferredPrompt) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      event: this.deferredPrompt,\r\n      showPrompt: async () => {\r\n        await this.installApp();\r\n      }\r\n    };\r\n  }\r\n\r\n  public isAppInstallable(): boolean {\r\n    return !this.isInstalled && this.deferredPrompt !== null;\r\n  }\r\n\r\n  public isAppInstalled(): boolean {\r\n    return this.isInstalled;\r\n  }\r\n\r\n  public isOnline(): boolean {\r\n    return this.isOnline;\r\n  }\r\n\r\n  public hasUpdate(): boolean {\r\n    return this.updateAvailable;\r\n  }\r\n\r\n  public getServiceWorkerRegistration(): ServiceWorkerRegistration | null {\r\n    return this.swRegistration;\r\n  }\r\n\r\n  // Offline functionality\r\n  public async cacheData(key: string, data: any): Promise<void> {\r\n    if ('caches' in window) {\r\n      try {\r\n        const cache = await caches.open('ai-gods-data');\r\n        const response = new Response(JSON.stringify(data));\r\n        await cache.put(`/data/${key}`, response);\r\n        console.log('üíæ Data cached successfully:', key);\r\n      } catch (error) {\r\n        console.error('‚ùå Failed to cache data:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  public async getCachedData(key: string): Promise<any | null> {\r\n    if ('caches' in window) {\r\n      try {\r\n        const cache = await caches.open('ai-gods-data');\r\n        const response = await cache.match(`/data/${key}`);\r\n        if (response) {\r\n          const data = await response.json();\r\n          console.log('üì¶ Data retrieved from cache:', key);\r\n          return data;\r\n        }\r\n      } catch (error) {\r\n        console.error('‚ùå Failed to retrieve cached data:', error);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Event dispatching\r\n  private dispatchEvent(eventName: string, data?: any): void {\r\n    const event = new CustomEvent(`pwa:${eventName}`, { detail: data });\r\n    window.dispatchEvent(event);\r\n  }\r\n\r\n  // Event listening\r\n  public on(eventName: string, callback: (event: CustomEvent) => void): void {\r\n    window.addEventListener(`pwa:${eventName}`, callback as EventListener);\r\n  }\r\n\r\n  public off(eventName: string, callback: (event: CustomEvent) => void): void {\r\n    window.removeEventListener(`pwa:${eventName}`, callback as EventListener);\r\n  }\r\n\r\n  // Utility methods\r\n  public async getAppVersion(): Promise<string> {\r\n    if (this.swRegistration && this.swRegistration.active) {\r\n      try {\r\n        const messageChannel = new MessageChannel();\r\n        return new Promise((resolve) => {\r\n          messageChannel.port1.onmessage = (event) => {\r\n            resolve(event.data.version);\r\n          };\r\n          \r\n          this.swRegistration!.active!.postMessage(\r\n            { type: 'GET_VERSION' },\r\n            [messageChannel.port2]\r\n          );\r\n        });\r\n      } catch (error) {\r\n        console.error('‚ùå Failed to get app version:', error);\r\n        return 'unknown';\r\n      }\r\n    }\r\n    return 'unknown';\r\n  }\r\n\r\n  public async clearCache(): Promise<void> {\r\n    if ('caches' in window) {\r\n      try {\r\n        const cacheNames = await caches.keys();\r\n        await Promise.all(\r\n          cacheNames.map(cacheName => caches.delete(cacheName))\r\n        );\r\n        console.log('üóëÔ∏è All caches cleared successfully');\r\n      } catch (error) {\r\n        console.error('‚ùå Failed to clear caches:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  public async unregisterServiceWorker(): Promise<void> {\r\n    if (this.swRegistration) {\r\n      try {\r\n        await this.swRegistration.unregister();\r\n        this.swRegistration = null;\r\n        console.log('‚úÖ Service Worker unregistered successfully');\r\n      } catch (error) {\r\n        console.error('‚ùå Failed to unregister Service Worker:', error);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const pwaService = new PWAService();\r\nexport default pwaService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}